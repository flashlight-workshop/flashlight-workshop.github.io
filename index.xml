<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Home on FLASHLIGHT</title><link>https://flashlight-workshop.github.io/</link><description>Recent content in Home on FLASHLIGHT</description><generator>Hugo -- gohugo.io</generator><language>en-gb</language><lastBuildDate>Wed, 23 Mar 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://flashlight-workshop.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Participants</title><link>https://flashlight-workshop.github.io/participants/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://flashlight-workshop.github.io/participants/</guid><description>I&amp;rsquo;m John Wickerson, and one thing I&amp;rsquo;d like to get out of this workshop is: I&amp;rsquo;m curious whether there are other properties of an HLS tool &amp;ndash; besides correctness &amp;ndash; that formal methods could help to guarantee.
Hi, I am Jianyi Cheng from Imperial College London. I have a talk today about optimizing HLS using Petri nets. People use formal methods to PROVE stuff, and I use formal methods to IMPROVE stuff.</description></item><item><title>Photo Gallery</title><link>https://flashlight-workshop.github.io/photos/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://flashlight-workshop.github.io/photos/</guid><description>Here are some photos of the great presentations held at FLASHLIGHT 2022.
Christian Pilato Ecenur Üstün Rachit Nigam Jianyi Cheng Yann Herklotz</description></item><item><title>Talk Summaries</title><link>https://flashlight-workshop.github.io/notes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://flashlight-workshop.github.io/notes/</guid><description>These notes have been taken from the Google Docs, which was edited live during the workshop.
Designing memory architectures with high-level synthesis: What could possibly go wrong? by Christian Pilato, Politecnico di Milano.
Notes Timing specifications not captured in interface description in verilog (i.e. input 1 should arrive 1 cycle after input 2) Using MLIR as an intermediate step, with various different input flows for different languages, to then target different outputs.</description></item></channel></rss>